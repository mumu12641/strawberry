use crate::ast::*;
use crate::token::Token;
use crate::lexer::{LineNum, LexicalError};

grammar<'input>;

// * => zero or more
// + => once or more
// ? => zero or once

pub Program = <class*>;

class: Class = {
    "CLASS" <class_name:"TYPE"> "{" <f:feature*> "}" ";" => Class {
        name: class_name,
        parent: None,
        features: f
    },
    "CLASS" <class_name:"TYPE"> "INHERITS" <parent_name:"TYPE"> "{" <f:feature*> "}" ";" => Class {
        name: class_name,
        parent: Some(parent_name),
        features: f
    },
};

feature: Feature = {
    // attr
    <attr_name:"ID"> ":" <type_name:"TYPE"> ";" => {
        Feature::Attribute(VarDecl {
            name: attr_name,
            type_: type_name,
            init: Box::new(None),
        })
    },

    <attr_name:"ID"> ":" <type_name:"TYPE"> "=" <e:single_expr> ";" => {
        Feature::Attribute(VarDecl{
            name:attr_name,
            type_:type_name,
            init:Box::new(Some(e)),
        })
    },
    
    // function
    "FUN" <method_name:"ID"> "(" <param_:comma_list<param>?>  ")" "->" <r_type:"TYPE"> "{" <e:semi_list<expr>>  "}" ";" => {
        Feature::Method(MethodDecl{
            name: method_name,
            param: Box::new(param_.unwrap_or(vec![])),
            return_type:r_type,
            body: Box::new(Some(e)),
        })
    },

    "FUN" <method_name:"ID"> "(" <param_:comma_list<param>?> ")" "->" <r_type:"TYPE"> "{"   "}"  ";"=> {
        Feature::Method(MethodDecl{
            name: method_name,
            param: Box::new(param_.unwrap_or(vec![])),
            return_type:r_type,
            body: Box::new(None),
        })
    },

};

param: ParamDecl = {
    <id:"ID"> ":" <t:"TYPE"> => (<>),
};

// let var
var: VarDecl = {
    <id:"ID"> ":" <type_name:"TYPE"> => VarDecl{
        name:id,
        type_: type_name,
        init: Box::new(None),
    },
    <id:"ID"> ":" <type_name:"TYPE"> "=" <e:single_expr> => VarDecl{
        name:id,
        type_: type_name,
        init: Box::new(Some(e)),
    },
};

// let assign if while 
expr: Expr = {
    "LET" <var_:comma_list<var>> ";"=> Expr::Let(Box::new(var_)),
    <id:"ID"> "=" <expr :math_expr>";" => Expr::Assignment(id, Box::new(expr)),

    <e:single_expr> "." <id:"ID"> "(" <args:comma_list<math_expr>?> ")" ";" => {
        Expr::Dispatch {
            target: Box::new(Some(e)),
            fun_name: id,
            actual: Box::new(args.unwrap_or(vec![])),
        }
    },
    <id:"ID"> "(" <args:comma_list<math_expr>?>  ")" ";"=> {
        Expr::Dispatch {
            target: Box::new(None),
            fun_name: id,
            actual: Box::new(args.unwrap_or(vec![])),
        }
    },

    "IF" "(" <test_:cond_expr> ")"  "THEN" "{" <then_:expr> "}" "ELSE" "{" <else_:expr> "}"  => Expr::Cond{
        test:Box::new(test_),
        then_body: Box::new(then_),
        else_body: Box::new(else_),
    },

    "IF" <test_:cond_expr>  "THEN" "{" <then_:expr> "}" "ELSE" "{" <else_:expr> "}"  => Expr::Cond{
        test:Box::new(test_),
        then_body: Box::new(then_),
        else_body: Box::new(else_),
    },

    "WHILE"  "(" <test_:cond_expr> ")" "{" <body_:expr> "}" => Expr::While{
        test:Box::new(test_),
        body: Box::new(body_),
    },

    "WHILE" <test_:cond_expr> "{" <body_:expr> "}" => Expr::While{
        test:Box::new(test_),
        body: Box::new(body_),
    },
    "RETURN"  <val:math_expr> ";"=> Expr::Return{
        val: Box::new(val),
    },
    math_expr,

};

single_expr:Expr = {
    <id:"ID"> => Expr::Identifier(<>),
    <s:"STR"> => Expr::Str(s),
    <b:"BOOL"> => Expr::Bool(b),
    <i:"INT"> => Expr::Int(i.parse().unwrap()), 
    "NEW" <class_name:"TYPE"> => Expr::New(<>), 
};

add_minus: MathOp = {
    "+" => MathOp::Add,
    "-" => MathOp::Minus,
};

mul_div: MathOp = {
    "/" => MathOp::Divide,
    "*" => MathOp::Mul,
};

cond_op: MathOp = {
    ">" => MathOp::More,
    "=>" => MathOp::MoreE,
    "<" => MathOp::Less,
    "<=" => MathOp::LessE,
    "==" => MathOp::Equal,
}

math_term:Expr ={
    <l:math_term> <op:mul_div> <r:single_expr> => Expr::Math {
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    },
    single_expr,
};

math_expr: Expr = {
    <l:math_expr> <op:add_minus> <r:math_term> => Expr::Math {
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    },
    math_term,
};

cond_expr: Expr = {
    <l:math_expr> <op:cond_op> <r:math_expr> => Expr::Math { 
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    },
    math_expr,
}


#[inline]
comma_list<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};

#[inline]
semi_list<T>:Vec<T> = {
    // <i1: T> <i2:(";" T)*> => {
        <i1: T> <i2: T*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e));
        items
    }
}


extern {
    type Location = LineNum;
    type Error = LexicalError;

    // Map parser terms to token values:
    enum Token{
        "CLASS" => Token::Class_,
        "FUN" => Token::Function,
        "RETURN" => Token::Return,
        "IF" => Token::If,
        "THEN" => Token::Then,
        "ELSE" => Token::Else,
        "INHERITS" => Token::Inherits,
        "LET" => Token::Let,
        "WHILE" => Token::While,
        "NEW" => Token::New,
        "ISVOID" => Token::Isvoid,
        "!" => Token::Not,
        "->" => Token::Arrow,

        "STR" => Token::StringConst(<String>),
        "INT" => Token::IntConst(<String>),
        "BOOL" => Token::BoolConst(<bool>),
        "TYPE" => Token::TypeId(<String>),
        "ID" => Token::Identifier(<String>),

        "=" => Token::Assign,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Divide,
        "*" => Token::Mul,
        "==" => Token::Equal,
        ">" => Token::More,
        "=>" => Token::MoreE,
        "<" => Token::Less,
        "<=" => Token::LessE,
        
        "{" => Token::Lbrace,
        "}" => Token::Rbrace,
        "(" => Token::Lparen,
        ")" => Token::Rparen,
        ";" =>Token::Semicolon,
        "." => Token::Period,
        "," => Token::Comma,
        ":" =>Token::Colon,
        "ERROR" => Token::Error(<String>),
    }

}

