use crate::grammar::ast::class::*;
use crate::grammar::ast::expr::*;
use crate::grammar::token::Token;
use crate::grammar::lexer::{LineNum, LexicalError};

grammar<'input>;

// * => zero or more
// + => once or more
// ? => zero or once
pub Program = <class*>;

class: Class = {
    <l:"CLASS"> <class_name:"TYPE"> "{" <f:feature*> "}" ";" => Class {
        name: class_name,
        parent: None,
        features: f,
        position: l.0,
        file_name: l.1,
    },
    <l:"CLASS"> <class_name:"TYPE"> "INHERITS" <parent_name:"TYPE"> "{" <f:feature*> "}" ";" => Class {
        name: class_name,
        parent: Some(parent_name),
        features: f,
        position: l.0,
        file_name: l.1,
    },
};

feature: Feature = {
    // attr
    <attr_name:"ID"> ":" <type_name:"TYPE"> ";" => {
        Feature::Attribute(VarDecl {
            name: attr_name.0,
            type_: type_name,
            init: Box::new(None),
            position: attr_name.1
        })
    },

    <attr_name:"ID"> ":" <type_name:"TYPE"> "=" <e:single_expr> ";" => {
        Feature::Attribute(VarDecl{
            name:attr_name.0,
            type_:type_name,
            init:Box::new(Some(e)),
            position: attr_name.1
        })
    },
    
    // function
    <pos:"FUN"> <method_name:"ID"> "(" <param_:comma_list<param>?>  ")" "->" <r_type:"TYPE"> "{" <e:semi_list<expr>>  "}" ";" => {
        Feature::Method(MethodDecl{
            name: method_name.0,
            param: Box::new(param_.unwrap_or(vec![])),
            return_type:r_type,
            body: Box::new(Some(e)),
            position: pos,
            // body: Box::new(Box::new(e)),
        })
    },

    <pos: "FUN"> <method_name:"ID"> "(" <param_:comma_list<param>?> ")" "->" <r_type:"TYPE"> "{"   "}"  ";"=> {
        Feature::Method(MethodDecl{
            name: method_name.0,
            param: Box::new(param_.unwrap_or(vec![])),
            return_type:r_type,
            body: Box::new(None),
            position: pos,
        })
    },

};

param: ParamDecl = {
    <id:"ID"> ":" <t:"TYPE"> => (id.0,t),
};

// let var
var: VarDecl = {
    <id:"ID"> ":" <type_name:"TYPE"> => VarDecl{
        name:id.0,
        type_: type_name,
        init: Box::new(None),
        position: id.1,
    },
    <id:"ID"> ":" <type_name:"TYPE"> "=" <e:single_expr> => VarDecl{
        name:id.0,
        type_: type_name,
        init: Box::new(Some(e)),
        position: id.1,
    },
};

// let assign if while 
expr: Expr = {
    "LET" <var_:comma_list<var>> ";"=> Expr::Let(Let{var_decls:Box::new(var_)}),
    <id:"ID"> "=" <expr :math_expr>";" => Expr::Assignment(Assignment{id:id.0, compute:Box::new(expr),position:id.1}),

    <e:single_expr> "." <id:"ID"> "(" <args:comma_list<math_expr>?> ")" ";" => {
        Expr::Dispatch (Dispatch{
            target: Box::new(Some(e)),
            fun_name: id.0,
            actual: Box::new(args.unwrap_or(vec![])),
            position: id.1
        })
    },


    <id:"ID"> "(" <args:comma_list<math_expr>?>  ")"  ";"=> {
        Expr::Dispatch (Dispatch{
            // target: Box::new(Some("self".to_string())),
            target:Box::new(Some(Expr::Identifier("self".to_string(), (0,0)))),
            fun_name: id.0,
            actual: Box::new(args.unwrap_or(vec![])),
            position: id.1
        })
    },

    <pos: "IF"> "(" <test_:cond_expr> ")"  "THEN" "{" <then_:expr*> "}" "ELSE" "{" <else_:expr*> "}"  => Expr::Cond(Cond{
        test:Box::new(test_),
        then_body: Box::new(then_),
        else_body: Box::new(else_),
        postion: pos,
    }),

    <pos: "IF"> <test_:cond_expr>  "THEN" "{" <then_:expr*> "}" "ELSE" "{" <else_:expr*> "}"  => Expr::Cond(Cond{
        test:Box::new(test_),
        then_body: Box::new(then_),
        else_body: Box::new(else_),
        postion: pos,
    }),

    <pos:"WHILE">  "(" <test_:cond_expr> ")" "{" <body_:expr*> "}" => Expr::While(While{
        test:Box::new(test_),
        body: Box::new(body_),
        postion: pos,
    }),

    <pos: "WHILE"> <test_:cond_expr> "{" <body_:expr*> "}" => Expr::While(While{
        test:Box::new(test_),
        body: Box::new(body_),
        postion: pos,
    }),
    <pos: "RETURN">  <val:math_expr> ";"=> Expr::Return(Return{
        val: Box::new(val),
        position: pos,
    }),
    math_expr,

};

single_expr:Expr = {
    <id:"ID"> => Expr::Identifier(id.0,id.1),
    <s:"STR"> => Expr::Str(s),
    <b:"BOOL"> => Expr::Bool(b),
    <i:"INT"> => Expr::Int(i.parse().unwrap()), 
    // <s:"SELF"> => Expr::Self_(s),
    
    "NEW" <class_name:"TYPE"> => Expr::New(<>), 

    <id:"ID"> "(" <args:comma_list<math_expr>?>  ")" => {
        Expr::Dispatch (Dispatch{
            // target: Box::new(Some("self".to_string())),
            target:Box::new(Some(Expr::Identifier("self".to_string(), (0,0)))),
            fun_name: id.0,
            actual: Box::new(args.unwrap_or(vec![])),
            position: id.1
        })
    },
    
    <e:single_expr> "." <id:"ID"> "(" <args:comma_list<math_expr>?> ")" => {
        Expr::Dispatch (Dispatch{
            target: Box::new(Some(e)),
            fun_name: id.0,
            actual: Box::new(args.unwrap_or(vec![])),
            position: id.1
        })
    },

};


add_minus: MathOp = {
    "+" => MathOp::ComputeOp(ComputeOp::Add),
    "-" => MathOp::ComputeOp(ComputeOp::Minus),
};

mul_div: MathOp = {
    "/" => MathOp::ComputeOp(ComputeOp::Divide),
    "*" => MathOp::ComputeOp(ComputeOp::Mul),
};

cond_op: MathOp = {
    ">" => MathOp::CondOp(CondOp::More),
    "=>" => MathOp::CondOp(CondOp::MoreE),
    "<" => MathOp::CondOp(CondOp::Less),
    "<=" => MathOp::CondOp(CondOp::LessE),
    "==" => MathOp::CondOp(CondOp::Equal),
    // "=>" => MathOp::CondOp::MoreE,
    // "<" => MathOp::CondOp::Less,
    // "<=" => MathOp::CondOp::LessE,
    // "==" => MathOp::CondOp::Equal,
}

math_term:Expr ={
    <l:math_term> <op:mul_div> <r:single_expr> => Expr::Math(Math {
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    }),
    single_expr,
};

math_expr: Expr = {
    <l:math_expr> <op:add_minus> <r:math_term> => Expr::Math(Math {
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    }),
    math_term,
};

cond_expr: Expr = {
    <l:math_expr> <op:cond_op> <r:math_expr> => Expr::Math(Math { 
        left: Box::new(l),
        op: Box::new(op),
        right: Box::new(r),
    }),
    math_expr,
}


#[inline]
comma_list<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};

#[inline]
semi_list<T>:Vec<T> = {
    // <i1: T> <i2:(";" T)*> => {
        <i1: T> <i2: T*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e));
        items
    }
}


extern {
    type Location = LineNum;
    type Error = LexicalError;
    // type Pos = Position;

    // Map parser terms to token values:
    enum Token{
        "CLASS" => Token::Class_(<(usize,usize)>,<String>),
        // "SELF" => Token::Self_,
        "FUN" => Token::Function(<(usize,usize)>),
        "RETURN" => Token::Return(<(usize,usize)>),
        "IF" => Token::If(<(usize,usize)>),
        "THEN" => Token::Then,
        "ELSE" => Token::Else(<(usize,usize)>),
        "INHERITS" => Token::Inherits,
        "LET" => Token::Let(<(usize,usize)>),
        "WHILE" => Token::While(<(usize,usize)>),
        "NEW" => Token::New(<(usize,usize)>),
        "ISVOID" => Token::Isvoid,
        // "SELF" => Token::Self_(<String>),
        "!" => Token::Not,
        "->" => Token::Arrow,

        "STR" => Token::StringConst(<String>),
        "INT" => Token::IntConst(<String>),
        "BOOL" => Token::BoolConst(<bool>),
        "TYPE" => Token::TypeId(<String>),
        "ID" => Token::Identifier(<String>,<(usize,usize)>),

        "=" => Token::Assign(<(usize,usize)>),
        "+" => Token::Plus,
        "-" => Token::Minus,
        "/" => Token::Divide,
        "*" => Token::Mul,
        "==" => Token::Equal,
        ">" => Token::More,
        "=>" => Token::MoreE,
        "<" => Token::Less,
        "<=" => Token::LessE,
        
        "{" => Token::Lbrace,
        "}" => Token::Rbrace,
        "(" => Token::Lparen,
        ")" => Token::Rparen,
        ";" =>Token::Semicolon,
        "." => Token::Period,
        "," => Token::Comma,
        ":" =>Token::Colon,
        "ERROR" => Token::Error(<String>),
    }

}

